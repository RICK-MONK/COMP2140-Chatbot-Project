const { Client, LocalAuth, Poll, MessageMedia } = require('whatsapp-web.js');
const qrcodeTerminal = require('qrcode-terminal');
const QRCode = require('qrcode');
const { generateInvoicePDF } = require('./invoice');
const { sendInvoiceEmail } = require('./email');
const path = require('path');
const fs = require('fs');
const { calculatePrice } = require('./pricing');
const { normalizeDate, isValidTime, buildCatalog, makeOrderHelpers } = require('./botHelpers');
const cleaningSupply = require('../cleaning_supply.json');

function createBot({ config, ordersStore }) {
    const client = new Client({ authStrategy: new LocalAuth() });
    const userState = {};
    const userData = {};
    let qrCodeDataUrl = null;
    let isClientReady = false;

    const catalog = buildCatalog(config);
    const { productOptions, blindCategoryLabels, getCategoryProducts } = catalog;
    const { sendOrderStatusList, buildManageOrderPoll } = makeOrderHelpers({ ordersStore, client });
    const supplyCategories = (cleaningSupply.categories || []).map(c => ({
        key: c.key,
        label: c.label,
        items: c.items || []
    }));
    const supplyItems = supplyCategories.flatMap(c => c.items.map(i => ({ ...i, categoryKey: c.key, categoryLabel: c.label })));
    const cleaningServiceOptions = ['Carpet Cleaning', 'Chair Cleaning', 'Rug Cleaning'];

    const createOrderId = () => `${Date.now()}${Math.floor(Math.random() * 1000).toString().padStart(3, '0')}`;
    const ensureUserData = (userId) => {
        if (!userData[userId]) userData[userId] = {};
        return userData[userId];
    };
    const findSupplyCategoryByLabel = (label) => supplyCategories.find(c => c.label.toLowerCase() === label.toLowerCase());
    const findSupplyItem = (name, categoryKey) => {
        const items = categoryKey ? supplyItems.filter(i => i.categoryKey === categoryKey) : supplyItems;
        return items.find(i => i.name.toLowerCase() === name.toLowerCase());
    };

    function resetUser(userId) {
        userState[userId] = null;
        userData[userId] = {};
    }

    function formatEstimateReceipt({ name, width, height, base, install, subtotal, gct, total }) {
        const lines = [
            '-----------------------------',
            '      OFFICIAL ESTIMATE',
            '-----------------------------',
            `Item   : ${name}`,
            `Size   : ${width}" x ${height}"`,
            `Base   : $${base.toLocaleString()}`,
            `Install: $${install.toLocaleString()}`,
            `Subtot.: $${subtotal.toLocaleString()}`,
            `GCT 15%: $${gct.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,
            '-----------------------------',
            `TOTAL  : $${total.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`,
            '-----------------------------'
        ];
        return lines.join('\n');
    }

    function createSupplyQuote({ item, purchaseType, quantity, existingEmail, existingFulfillment }) {
        const pricePer = purchaseType === 'case' ? item.casePrice : item.unitPrice;
        if (pricePer === null || pricePer === undefined) return null;
        const qty = Number(quantity || 0);
        if (!Number.isFinite(qty) || qty <= 0) return null;
        const base = pricePer * qty;
        const install = 0;
        const subtotal = base;
        const gct = +(subtotal * 0.15).toFixed(2);
        const total = subtotal + gct;
        const label = `${qty} x ${item.name} (${purchaseType === 'case' ? 'Case' : 'Unit'}${item.unitSize ? `, ${item.unitSize}` : ''})`;

        return {
            width: 0,
            height: 0,
            quantity: qty,
            product: label,
            description: item.categoryLabel ? `${item.categoryLabel} supply` : 'Cleaning Supply',
            price: total.toFixed(2),
            email: existingEmail || null,
            fulfillment: existingFulfillment || null,
            priceBreakdown: {
                base,
                install,
                subtotal,
                gct
            }
        };
    }

    async function placeOrder({ userId, user, displayName }) {
        const cart = user.cart || [];
        const fulfillment = user.lastQuote?.fulfillment || user.fulfillment;
        if (!cart.length) {
            await client.sendMessage(userId, 'No order to confirm. Please start over.');
            resetUser(userId);
            return;
        }
        else if ((option === 'Delivery (3-4 Days)' || option === 'Pickup') && userState[userId] === 'choose_fulfillment') {
            if (user.lastQuote) user.lastQuote.fulfillment = option;
            user.fulfillment = option;
            await placeOrder({ userId, user, displayName });
        }
        if (!fulfillment) {
            userState[userId] = 'choose_fulfillment';
            const poll = new Poll('Choose delivery method to place order:', ['Delivery (3-4 Days)', 'Pickup']);
            await client.sendMessage(userId, poll);
            return;
        }
        const order = buildOrderFromCart({
            cart,
            email: user.lastQuote?.email,
            displayName,
            phone: userId.replace('@c.us', ''),
            fulfillment
        });
        ordersStore.saveOrder(order);
        await client.sendMessage(userId, `Order #${order.id} placed!`);
        resetUser(userId);
    }

    function calculateCartTotals(cart) {
        return (cart || []).reduce((acc, item) => {
            const base = Number(item.priceBreakdown?.base || 0);
            const install = Number(item.priceBreakdown?.install || 0);
            const subtotal = item.priceBreakdown?.subtotal !== undefined
                ? Number(item.priceBreakdown.subtotal)
                : base + install;
            const gct = item.priceBreakdown?.gct !== undefined
                ? Number(item.priceBreakdown.gct)
                : subtotal * 0.15;
            const total = item.price !== undefined ? Number(item.price) : subtotal + gct;

            acc.base += base;
            acc.install += install;
            acc.subtotal += subtotal;
            acc.gct += gct;
            acc.total += total;
            return acc;
        }, { base: 0, install: 0, subtotal: 0, gct: 0, total: 0 });
    }

    function buildOrderFromCart({ cart, email, displayName, phone, fulfillment, includeStatus = true }) {
        if (!cart || !cart.length) return null;
        const totals = calculateCartTotals(cart);
        const items = cart.map(item => ({
            width: item.width,
            height: item.height,
            quantity: item.quantity || 1,
            product: item.product,
            description: item.description,
            priceBreakdown: item.priceBreakdown
        }));
        const details = items.map(i => {
            if (i.description) return `${i.product}`;
            return `${i.width}" x ${i.height}" (${i.product})`;
        }).join(' | ');

        return {
            id: createOrderId(),
            date: new Date().toLocaleDateString(),
            name: displayName || "Customer",
            phone,
            items,
            details,
            price: totals.total.toFixed(2),
            email: email || 'N/A',
            fulfillment: fulfillment || 'N/A',
            priceBreakdown: {
                base: totals.base,
                install: totals.install,
                subtotal: totals.subtotal,
                gct: totals.gct
            },
            status: includeStatus ? 'PENDING DELIVERY' : undefined
        };
    }

    client.on('qr', (qr) => {
        qrcodeTerminal.generate(qr, { small: true });
        QRCode.toDataURL(qr, (err, url) => {
            if (!err) { qrCodeDataUrl = url; isClientReady = false; }
        });
    });

    client.on('ready', () => {
        console.log('>>> SYSTEM ONLINE <<<');
        isClientReady = true;
        qrCodeDataUrl = null;
    });

    client.on('message', async msg => {
        if (msg.from.includes('status')) return;

        const userId = msg.from;
        const text = msg.body.toLowerCase();
        const user = ensureUserData(userId);
        user.displayName = msg._data.notifyName || "Customer";

        const greetings = ['hi', 'hello', 'hey', 'heyy', 'good morning', 'good afternoon', 'good evening', "what's up", 'whats up', 'sup', 'yo', 'menu'];
        if (text === 'cancel' || text === 'stop') {
            resetUser(userId);
            await client.sendMessage(userId, 'Cancelled. Type "Hi" to start over.');
            return;
        }
        if (greetings.some(g => text.startsWith(g))) {
            resetUser(userId);
            await client.sendMessage(userId, 'Welcome to White Rose Interiors!');
            const poll = new Poll('How can we help you today?', [
                'üõçÔ∏è Goods/Services',
                'üßæ Manage Orders',
                'üì¶ Get Order Status',
                '‚òéÔ∏è Contact Support',
                '‚ùì FAQ'
            ]);
            await client.sendMessage(userId, poll);
            return;
        }

        if (userState[userId] === 'awaiting_cleaning_service_message') {
            await client.sendMessage(userId, 'Thanks! We have noted your cleaning service request. A rep will follow up.');
            resetUser(userId);
            return;
        }

        if (userState[userId] === 'awaiting_cleaning_supply_message') {
            const cat = user.supplyCategory || 'Supplies';
            await client.sendMessage(userId, `Noted for ${cat}. A rep will confirm availability and pricing.`);
            resetUser(userId);
            return;
        }

        if (userState[userId] === 'waiting_for_width') {
            const width = parseFloat(text);
            if (!Number.isFinite(width) || width <= 0) {
                await client.sendMessage(userId, 'Please enter a positive number for width.');
                return;
            }
            user.width = width;
            userState[userId] = 'waiting_for_height';
            await client.sendMessage(userId, 'Enter Height (inches):');
            return;
        }

        if (userState[userId] === 'waiting_for_height') {
            const height = parseFloat(text);
            if (!Number.isFinite(height) || height <= 0) {
                await client.sendMessage(userId, 'Please enter a positive number for height.');
                return;
            }

            const width = user.width;
            const productKey = user.selectedProduct || 'illusion_cat3';
            const result = calculatePrice(productKey, width, height);
            if (!result || result.error || result.price === undefined || result.price === null) {
                await client.sendMessage(userId, result?.error || 'Size not available in standard list. Contacting support...');
                userState[userId] = null;
                return;
            }

            const subtotal = result.price + config.installation_fee;
            const gct = +(subtotal * 0.15).toFixed(2);
            const finalPrice = subtotal + gct;

            if (!user.cart) user.cart = [];
            const quote = {
                width,
                height,
                price: finalPrice.toFixed(2),
                product: result.name,
                email: user.lastQuote?.email || null,
                fulfillment: user.lastQuote?.fulfillment || null,
                priceBreakdown: {
                    base: result.price,
                    install: config.installation_fee,
                    subtotal,
                    gct
                }
            };
            user.lastQuote = quote;
            user.cart.push(quote);

            const receipt = formatEstimateReceipt({
                name: result.name,
                width,
                height,
                base: result.price,
                install: config.installation_fee,
                subtotal,
                gct,
                total: finalPrice
            });
            await client.sendMessage(userId, 'Estimate generated.');
            await client.sendMessage(userId, '```' + receipt + '```');

            userState[userId] = 'quote_next_step';
            const poll = new Poll('Add another item or finish?', ['Add another blind', 'Add another supply', 'Finish & get PDF']);
            await client.sendMessage(userId, poll);
            return;
        }

        if (userState[userId] === 'supply_quantity') {
            const qty = Number(text);
            const item = user.supplyItem;
            if (!item) {
                await client.sendMessage(userId, 'Please pick an item first.');
                resetUser(userId);
                return;
            }
            if (!Number.isFinite(qty) || qty <= 0) {
                await client.sendMessage(userId, 'Enter a valid quantity (number > 0).');
                return;
            }
            const quote = createSupplyQuote({
                item: { ...item, categoryLabel: user.supplyCategory },
                purchaseType: user.supplyPurchaseType || 'unit',
                quantity: qty,
                existingEmail: user.lastQuote?.email,
                existingFulfillment: user.lastQuote?.fulfillment
            });
            if (!quote) {
                await client.sendMessage(userId, 'Could not create an estimate for that item.');
                resetUser(userId);
                return;
            }
            if (!user.cart) user.cart = [];
            user.cart.push(quote);
            user.lastQuote = quote;
            const totals = calculateCartTotals(user.cart);
            await client.sendMessage(userId, `Added to cart: ${quote.product}. Current total (incl. GCT): $${totals.total.toFixed(2)}`);
            userState[userId] = 'quote_next_step';
            const poll = new Poll('Add another item or finish?', ['Add another blind', 'Add another supply', 'Finish & get PDF']);
            await client.sendMessage(userId, poll);
            return;
        }

        if (userState[userId] === 'manage_resched_date') {
            const date = text.trim();
            user.reschedDate = date;
            userState[userId] = 'manage_resched_time';
            await client.sendMessage(userId, 'Enter new time (e.g., 2:30 PM):');
            return;
        }

        if (userState[userId] === 'manage_resched_time') {
            const time = text.trim();
            const id = user.manageOrderId;
            const date = user.reschedDate;
            if (!id || !date) {
                await client.sendMessage(userId, 'No order selected. Please start again with Manage Orders.');
                resetUser(userId);
                return;
            }
            const normalizedDate = normalizeDate(date);
            if (!normalizedDate) {
                await client.sendMessage(userId, 'Invalid date. Please enter as YYYY-MM-DD:');
                userState[userId] = 'manage_resched_date';
                return;
            }
            if (!isValidTime(time)) {
                await client.sendMessage(userId, 'Invalid time. Please use HH:MM or HH:MM AM/PM:');
                return;
            }
            ordersStore.updateOrder(id, { scheduledDate: normalizedDate, scheduleTime: time.trim() });
            await client.sendMessage(userId, `Order #${id} rescheduled to ${normalizedDate} at ${time}.`);
            resetUser(userId);
            return;
        }

        if (userState[userId] === 'typing_email') {
            if (text.includes('@')) {
                user.lastQuote = user.lastQuote || {};
                user.lastQuote.email = msg.body.trim();
                await client.sendMessage(userId, 'Email saved.');

                try {
                    const cart = user.cart || [];
                    const order = buildOrderFromCart({
                        cart,
                        email: user.lastQuote.email,
                        displayName: user.displayName,
                        phone: userId.replace('@c.us', ''),
                        fulfillment: user.lastQuote.fulfillment,
                        includeStatus: false
                    });
                    if (order && cart.length > 0) {
                        const invoicesDir = path.join(__dirname, '..', 'public', 'invoices');
                        if (!fs.existsSync(invoicesDir)) fs.mkdirSync(invoicesDir, { recursive: true });
                        const fileName = `Estimate_${order.id}.pdf`;
                        const pdfPath = path.join(invoicesDir, fileName);
                        await generateInvoicePDF(order, fileName, "ESTIMATE");
                        const mailed = await sendInvoiceEmail(order.email, order, pdfPath);
                        if (mailed) {
                            await client.sendMessage(userId, 'Estimate emailed to you.');
                        } else {
                            await client.sendMessage(userId, 'Could not send email right now.');
                        }
                    }
                } catch (err) {
                    console.error('Immediate email send error', err);
                    await client.sendMessage(userId, 'Could not send email right now.');
                }
                userState[userId] = 'waiting_for_fulfillment';
                const poll = new Poll('How would you like to receive this?', ['Delivery (3-4 Days)', 'Pickup']);
                await client.sendMessage(userId, poll);
            } else {
                await client.sendMessage(userId, 'Please enter a valid email address.');
            }
            return;
        }
    });

    client.on('vote_update', async (vote) => {
        if (vote.selectedOptions.length === 0) return;
        const userId = vote.voter;
        const optionRaw = vote.selectedOptions[0].name;
        const option = optionRaw.replace(/^[^a-zA-Z0-9]+/, '').trim();
        const optLower = option.toLowerCase();
        const user = ensureUserData(userId);
        const displayName = user.displayName || "Customer";

        if (option === 'Goods/Services') {
            const subPoll = new Poll('Select a Category:', ['ü™ü Blinds', 'üßπ Cleaning Services', 'üß¥ Cleaning Supplies']);
            await client.sendMessage(userId, subPoll);
        }
        else if (option === 'Contact Support') {
            const contactMsg = [
                'Support options:',
                '- Reply here for chat (we respond ASAP during business hours).',
                `- Call us: ${config.company_phone}`,
                '- Email: support@whiteroseinteriors.com (include your order # if you have one).'
            ].join('\n');
            await client.sendMessage(userId, contactMsg);
            const contextLines = [];
            if (user.cart && user.cart.length) contextLines.push(`Recent item: ${user.cart[user.cart.length - 1].product}`);
            if (user.lastQuote?.fulfillment) contextLines.push(`Fulfillment pref: ${user.lastQuote.fulfillment}`);
            if (contextLines.length) {
                await client.sendMessage(userId, 'We\'ll share this context with a rep:\n' + contextLines.join('\n'));
            }
        }
        else if (option === 'Get Order Status') {
            await sendOrderStatusList(userId);
        }
        else if (option === 'Manage Orders') {
            const pollData = buildManageOrderPoll(userId);
            if (!pollData) {
                await client.sendMessage(userId, 'No orders found to manage.');
            } else {
                userState[userId] = 'manage_select_order';
                user.manageOrders = pollData.orders;
                const poll = new Poll('Select an order to manage:', pollData.options);
                await client.sendMessage(userId, poll);
            }
        }
        else if (option === 'FAQ') {
            const faq = [
                '*FAQ*',
                '',
                'Hours: Mon-Fri 8:30 AM - 4:30 PM',
                'Location: 30-32 Red Hills Road',
                'Delivery/Pickup: Typically 3-4 business days after confirmation',
                'Quotes: Blinds include install + GCT; supplies are priced per unit/case with GCT',
                'Orders: You can reschedule/cancel via Manage Orders or reply here',
                'Payments: Bank transfer details on invoice; confirm with your rep if you prefer cash/card',
                'Returns/Warranty: Contact support for defects or installation issues',
                'Support: Call us at ' + config.company_phone + ' or reply here for help'
            ].join('\n');
            await client.sendMessage(userId, faq);
        }

        else if (option === 'Blinds') {
            const catPoll = new Poll('Choose a blinds family:', blindCategoryLabels);
            await client.sendMessage(userId, catPoll);
        }
        else if (option === 'Cleaning Services') {
            userState[userId] = 'select_cleaning_service';
            const poll = new Poll('üßπ Select a cleaning service:', cleaningServiceOptions.map(s => `ü™£ ${s}`));
            await client.sendMessage(userId, poll);
        }
        else if (option === 'Cleaning Supplies') {
            if (!supplyCategories.length) {
                userState[userId] = 'awaiting_cleaning_supply_message';
                await client.sendMessage(userId, 'Please leave a message describing what you need.');
            } else {
                userState[userId] = 'select_supply_category';
                const poll = new Poll('Select a supply category:', supplyCategories.map(c => c.label));
                await client.sendMessage(userId, poll);
            }
        }

        else if (blindCategoryLabels.map(l => l.toLowerCase()).includes(optLower)) {
            const prods = getCategoryProducts(option);
            const prodLabels = prods.map(p => p.label);
            const poll = new Poll('Select a product:', prodLabels);
            await client.sendMessage(userId, poll);
        }
        else if (productOptions.find(p => p.label.toLowerCase() === optLower)) {
            const chosen = productOptions.find(p => p.label.toLowerCase() === optLower);
            const data = ensureUserData(userId);
            data.selectedProduct = chosen.key;
            data.displayName = displayName;
            userState[userId] = 'waiting_for_width';
            await client.sendMessage(userId, 'Enter Width (inches):');
        }
        else if (Object.entries(config.products).find(([k, v]) => v.name.toLowerCase() === optLower)) {
            const found = Object.entries(config.products).find(([k, v]) => v.name.toLowerCase() === optLower);
            const data = ensureUserData(userId);
            data.selectedProduct = found[0];
            data.displayName = displayName;
            userState[userId] = 'waiting_for_width';
            await client.sendMessage(userId, 'Enter Width (inches):');
        }

        else if (userState[userId] === 'select_supply_category') {
            const category = findSupplyCategoryByLabel(option);
            if (!category) {
                await client.sendMessage(userId, 'Please pick a listed category.');
                return;
            }
            if (!category.items.length) {
                await client.sendMessage(userId, 'No items in that category. Please choose another.');
                return;
            }
            user.supplyCategory = category.label;
            user.supplyCategoryKey = category.key;
            user.supplyItems = category.items;
            userState[userId] = 'select_supply_item';
            const itemOptions = category.items.map(i => i.name);
            await client.sendMessage(userId, 'Pick a supply item:');
            const poll = new Poll(`Items in ${category.label}:`, itemOptions);
            await client.sendMessage(userId, poll);
        }
        else if (userState[userId] === 'select_supply_item') {
            const list = user.supplyItems || [];
            const selected = list.find(i => i.name.toLowerCase() === option.toLowerCase());
            if (!selected) {
                await client.sendMessage(userId, 'Please select an item from the list.');
                return;
            }
            user.supplyItem = selected;
            if (selected.casePrice && selected.casePrice > 0) {
                userState[userId] = 'supply_pack_choice';
                const poll = new Poll('How would you like to purchase?', [
                    `Per Unit ($${selected.unitPrice})`,
                    `Case ($${selected.casePrice})`
                ]);
                await client.sendMessage(userId, poll);
            } else {
                user.supplyPurchaseType = 'unit';
                userState[userId] = 'supply_quantity';
                await client.sendMessage(userId, `Enter quantity for ${selected.name} (unit price $${selected.unitPrice}):`);
            }
        }
        else if (userState[userId] === 'select_cleaning_service') {
            if (!cleaningServiceOptions.map(s => s.toLowerCase()).includes(optLower)) {
                await client.sendMessage(userId, 'Please pick one of the listed cleaning services.');
                return;
            }
            await client.sendMessage(userId, `${option} pricing is currently unavailable. A rep will follow up.`);
            resetUser(userId);
        }
        else if (userState[userId] === 'supply_pack_choice') {
            const item = user.supplyItem;
            if (!item) {
                await client.sendMessage(userId, 'Please pick an item first.');
                resetUser(userId);
                return;
            }
            const lower = option.toLowerCase();
            if (lower.includes('case')) {
                if (!item.casePrice && item.casePrice !== 0) {
                    await client.sendMessage(userId, 'Case pricing not available. Please choose Per Unit.');
                    return;
                }
                user.supplyPurchaseType = 'case';
            } else {
                user.supplyPurchaseType = 'unit';
            }
            userState[userId] = 'supply_quantity';
            const price = user.supplyPurchaseType === 'case' ? item.casePrice : item.unitPrice;
            await client.sendMessage(userId, `Enter quantity for ${item.name} (${user.supplyPurchaseType === 'case' ? 'cases' : 'units'}, price $${price}):`);
        }

        else if (option === 'Yes, email me') {
            userState[userId] = 'typing_email';
            await client.sendMessage(userId, 'Please type your email address:');
        }
        else if (option === 'No, thanks') {
            userState[userId] = 'final_confirm';
            const confirmPoll = new Poll('Send email or confirm order?', ['Send email', 'Confirm Order', 'Cancel']);
            await client.sendMessage(userId, confirmPoll);
        }

        else if (option === 'Add another blind') {
            userState[userId] = 'waiting_for_width';
            await client.sendMessage(userId, 'Enter Width (inches):');
        }
        else if (option === 'Add another supply') {
            if (!supplyCategories.length) {
                await client.sendMessage(userId, 'Supply catalog not available. Type your request and a rep will assist.');
                userState[userId] = 'awaiting_cleaning_supply_message';
            } else {
                userState[userId] = 'select_supply_category';
                const poll = new Poll('Select a supply category:', supplyCategories.map(c => c.label));
                await client.sendMessage(userId, poll);
            }
        }
        else if (option === 'Finish & get PDF') {
            const cart = user.cart || [];
            if (cart.length === 0) {
                await client.sendMessage(userId, 'No items found. Start by selecting a product.');
                userState[userId] = null;
                return;
            }

            const order = buildOrderFromCart({
                cart,
                email: user.lastQuote?.email,
                displayName,
                phone: userId.replace('@c.us', ''),
                fulfillment: user.lastQuote?.fulfillment,
                includeStatus: false
            });

            const totals = calculateCartTotals(cart);
            await client.sendMessage(userId, `Estimate complete. Total: $${totals.total.toFixed(2)}`);

            try {
                const fileName = `Estimate_${order.id}.pdf`;
                const pdfPath = await generateInvoicePDF(order, fileName, "ESTIMATE");
                const media = MessageMedia.fromFilePath(pdfPath);
                await client.sendMessage(userId, media);
            } catch (err) {
                console.error('PDF send error', err);
                await client.sendMessage(userId, 'Could not send PDF at this time.');
            }

            userState[userId] = 'final_confirm';
            const confirmPoll = new Poll('Send email or confirm order?', ['Send email', 'Confirm Order', 'Cancel']);
            await client.sendMessage(userId, confirmPoll);
        }

        else if (userState[userId] === 'final_confirm') {
            if (option === 'Send email') {
                userState[userId] = 'typing_email';
                await client.sendMessage(userId, 'Please type your email address:');
            } else if (option === 'Confirm Order') {
                await placeOrder({ userId, user, displayName });
            } else if (option === 'Cancel') {
                await client.sendMessage(userId, 'Cancelled. Type "Hi" to start over.');
                resetUser(userId);
            }
        }

        else if (option === 'Confirm Order') {
            const quote = user.lastQuote;
            if (!quote) {
                await client.sendMessage(userId, 'Please generate a quote first (select a product and enter size).');
                resetUser(userId);
                return;
            }
            await placeOrder({ userId, user, displayName: user.displayName || "Customer" });
        }
        else if (option === 'Cancel') {
            await client.sendMessage(userId, 'Order cancelled. Type "Hi" to start over.');
            resetUser(userId);
        }

        else if (userState[userId] === 'manage_select_order') {
            const match = option.match(/#(\d+)/);
            if (!match) {
                await client.sendMessage(userId, 'Please select a valid order option.');
                return;
            }
            const id = match[1];
            user.manageOrderId = id;
            userState[userId] = 'manage_action';
            const poll = new Poll(`Order #${id}: choose an action`, ['Reschedule', 'Cancel']);
            await client.sendMessage(userId, poll);
        }
        else if (userState[userId] === 'manage_action') {
            const id = user.manageOrderId;
            if (!id) {
                await client.sendMessage(userId, 'No order selected. Please start with Manage Orders.');
                resetUser(userId);
                return;
            }
            if (option === 'Reschedule') {
                userState[userId] = 'manage_resched_date';
                await client.sendMessage(userId, 'Enter new date (YYYY-MM-DD):');
            } else if (option === 'Cancel') {
                userState[userId] = 'manage_cancel_confirm';
                const poll = new Poll(`Cancel order #${id}?`, ['Yes, cancel', 'No']);
                await client.sendMessage(userId, poll);
            }
        }
        else if (userState[userId] === 'manage_cancel_confirm') {
            const id = user.manageOrderId;
            if (!id) {
                await client.sendMessage(userId, 'No order selected. Please start with Manage Orders.');
                resetUser(userId);
                return;
            }
            if (option === 'Yes, cancel') {
                const deleted = ordersStore.deleteOrder(id);
                if (deleted) {
                    await client.sendMessage(userId, `Order #${id} cancelled.`);
                } else {
                    await client.sendMessage(userId, `Could not cancel order #${id}.`);
                }
                resetUser(userId);
            } else if (option === 'No') {
                await client.sendMessage(userId, 'Cancelled action aborted.');
                resetUser(userId);
            }
        }
    });

    client.initialize();

    const getSystemStatus = () => ({ ready: isClientReady, qr: qrCodeDataUrl });

    return { client, getSystemStatus };
}

module.exports = { createBot };

